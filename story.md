DropTh.at; OpenResty events server
==================================

[DropTh.at](https://dropth.at/) is a chat service demo built with OpenResty. It secures your messages using a combination of traditional https and clientside crypto. Chat rooms are randomly generated by the client and can be shared by sharing the room's full url. The encryption keys are stored in the #fragment-identifier and are not sent to the server. That means the url is the room password. The core server and client demo are [open source](https://github.com/cagerton/dropthat).

Reality check: It still relies on a trustworthy host and on SSL to deliver the initial html+js. It is just a is a demo. See [Crypto.md](https://github.com/cagerton/dropthat/blob/master/crypto.md).

### Context: Javascript EventSource API:

I'm using the [EventSource API](http://www.w3.org/TR/eventsource/) for delivering messages.  It is [supported](http://caniuse.com/#feat=eventsource) by all the browsers that I currently care about (and can be shimmed into some by Microsoft).  The protocol is just a chunked HTTP stream with content-type "text/event-source" and formatted event messages.  It has a very low overhead and it plays nicely with the pub-sub pattern.

Here are the headers and the first event in a stream (as rendered by curl):
```http
< HTTP/1.1 200 OK
< Content-Type: text/event-stream
< Server: dropth.at
< Connection: keep-alive
< Transfer-Encoding: chunked
<
event:count
data:count=2

```
And here's how you could capture it:
```javascript
var events = new EventSource( '<event-source-url>' );
events.addEventListener('count', function(c){ console.log("Got ", c); });
```
>Got count=2

### Nginx, Lua, and OpenResty:

The server is built with [OpenResty](http://openresty.org/); that's Nginx, Lua, and a few extra modules. Leafo has a [nice intro](http://leafo.net/posts/creating_an_image_server.html) to building with OpenResty if you're not familiar. I highly suggest you check it out.

I'll assume you understand the basics of Nginx and Lua from this point.  Here are my core pub/sub locations in the nginx config. [Full Version](https://github.com/cagerton/dropthat/blob/master/chat.conf)
```nginx
worker_processes 1;
http {
    init_by_lua 'chat = require "chat"';

    server {
        listen 80 so_keepalive=20s:3s:6;
        set_by_lua $dontcare 'chat.check_init()';

        location ~ "^/sub/(?P<channel>[a-zA-Z\d_-]+)$" {
            lua_socket_log_errors off;
            lua_check_client_abort on;
            content_by_lua 'chat.event_source_location(ngx.var.channel)';
        }

        location ~ "^/pub/(?P<channel>[a-zA-Z\d_-]+)$" {
            client_max_body_size 32k;
            content_by_lua '
                ngx.req.read_body()
                local message = ngx.escape_uri(ngx.var.request_body)
                chat.publish_event(ngx.var.channel, nil, nil, message)
            ';
        }
```
* I've loaded the chat module as a thread global (happens once during while loading the config). 
* I'm start the a light background thread by calling chat.check_init()
* The /sub/&lt;channel-id> location calls chat.event_source_location() function.
* Likewise, the pub location really just hits chat.publish_event() function.

And here's the lua code that handles the subscribe location. [full version: chat.lua](https://github.com/cagerton/dropthat/blob/master/chat.lua):
```lua
function event_source_location(channel_id)
    local sock, err = ngx.req.socket(true) -- hijack the request socket
    sock:send(http_header)                 -- send same header as above

    local function cleanup()
        remove_socket(channel_id, sock)
        ngx.exit(499)
    end
    local ok, err = ngx.on_abort(cleanup)  -- handle disconnect

    add_socket(channel_id, sock)           -- add socket to data structure
    local loops=0
    while 1 do
        ngx.sleep(19.31)
        send_blank(sock)     -- periodic tick message :\r\n
    end
end

local function add_socket(channel_id, socket)
    local channel = get_or_create_channel(channel_id)
    channel.sockets[socket] = ngx.now()
    update_channel(channel_id)
end

local function update_channel(channel_id)
    local channel = channels[channel_id]
    if not channel.announce_queued then
        push_update_queue(channel_id)
        channel.announce_queued = true
    end
end
```
For reference, [ngx.sleep](https://github.com/chaoslawful/lua-nginx-module#ngxsleep) is nonblocking. In this case, the lua "light thread" handling this request wakes up every 19ish seconds just send a simple no-op message to keep the connection alive.

The publish_event function is strangely simple too.
```lua
function publish_event(channel_id, event_id, event, message)
    local channel = channels[channel_id]
    if channel then
        local chunk = format_event(event_id, event, message) --chunk & event-stream format
        for sock,start_time in pairs(channel.sockets) do
            local bytes, err = sock:send(chunk)
            if bytes ~= string.len(chunk) then
                -- handle error here.
                ngx.log(ngx.ERR, "failed to write event", err)
            end
        end
    end
end
```
The server sends "count=N" messages when the number of subscibers for a channel changes. These messages need to be rate limited when dealing with large numbers of clients.

The check_init() function starts the notify_thread() exactly once. That notify thread regulates the rate of updates.
```lua
function check_init()
    ngx.timer.at(0, notify_thread)
    check_init = function() end
end

local function notify_thread(premature)
    local loops = 0
    while true do
        local channel_id = pop_update_queue()
        if channel_id then
            local now = ngx.now();
            local channel = channels[channel_id]
            if channel and now < 0.373 + channel.last_announce then
                ngx.sleep(0.373) -- oversleeps a tiny bit,
                                 -- but queue order means it's ok.
            end
            channel = channels[channel_id]
            if channel then
                channel.announce_queued = false
                publish_channel_count(channel_id)
            end
        else
            ngx.sleep(.127)
        end
    end
end
```
Pretty cool, huh? 

...

